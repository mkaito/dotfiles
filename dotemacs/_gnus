;; -*- Lisp -*-

;; Boku desu ^_^
(setq user-mail-address "me@mkaito.com")
(setq user-full-name "Michishige Kaito")

;; Sort by reverse score, then by subject, and finally by number.
(setq gnus-thread-sort-functions
      '(gnus-thread-sort-by-number
	gnus-thread-sort-by-subject
	(not gnus-thread-sort-by-total-score)))

;; Group line format. Includes correct unread count (see below)
(setq gnus-group-line-format "%M%S%p%P%5uy:%B%(%g%)%O\n")

;; Setting the imap-ssl-program like this isn't strictly necessary, but
;; I do it anyway since I'm paranoid. (I think it will default to
;; `-ssl2' instead of `-tls1' if you don't do this.)
(setq imap-ssl-program "openssl s_client -tls1 -connect %s:%p")

;; Since I use gnus primarily for mail and not for reading News, I
;; make my IMAP setting the default method for gnus.
(setq gnus-select-method '(nnimap "mkaito.com"
				  (nnimap-address "imap.gmail.com")
				  (nnimap-server-port 993)
				  (nnimap-stream ssl)))

;; The default will match [Gmail] groups, which I'd like to display.
(setq gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")

;; Fetch only part of the article if we can.  I saw this in someone
;; else's .gnus
(setq gnus-read-active-file 'some)

;; Tree view for groups.  I like the organisational feel this has.
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)

;; Threads!  I hate reading un-threaded email -- especially mailing
;; lists.  This helps a ton!
(setq gnus-summary-thread-gathering-function 
      'gnus-gather-threads-by-subject)

;; Also, I prefer to see only the top level message.  If a message has
;; several replies or is part of a thread, only show the first
;; message.  'gnus-thread-ignore-subject' will ignore the subject and
;; look at 'In-Reply-To:' and 'References:' headers.
(setq gnus-thread-hide-subtree t)
(setq gnus-thread-ignore-subject t)

(setq message-send-mail-function 'smtpmail-send-it
      send-mail-function 'smtpmail-send-it
      smtpmail-starttls-credentials '(("smtp.gmail.com" 25 nil nil))
      smtpmail-auth-credentials '(("smtp.gmail.com" 25 "me@mkaito.com" nil))
      smtpmail-default-smtp-server "smtp.gmail.com"
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 25)
(require 'smtpmail)

;; IMAP Keep alive
(setq imap-ping-interval (* 10 60))
(setq imap-ping-timer nil)

(defun imap-ping-handler ()
  ;; ping all active IMAP servers in `nnimap-server-buffer-alist'
  (when (boundp 'nnimap-server-buffer-alist)
    (let ((servers nil))
      (mapc
       (lambda (server-buffer)
         (let ((server (car server-buffer))
               (buffer (cadr server-buffer)))
           (when (and (get-buffer buffer) (not (member server servers)))
             (ignore-errors
               (with-local-quit
                 (with-temp-message
                     (format "Pinging %s..." server)
                   (imap-send-command-wait "NOOP" buffer)
                   (message "Pinging %s...done" server))))
             (setq servers (cons server servers)))))
       nnimap-server-buffer-alist)))

  (let* ((current (current-time))
	 (timer imap-ping-timer)
	 ;; compute the time when this timer will run again
	 (next-time (timer-relative-time
		     (list (aref timer 1) (aref timer 2) (aref timer 3))
		     (* 5 (aref timer 4)) 0)))
    ;; if the activation time is far in the past, skip executions
    ;; until we reach a time in the future.  This avoids a long
    ;; pause if Emacs has been suspended for hours.
    (or (> (nth 0 next-time) (nth 0 current))
	(and (= (nth 0 next-time) (nth 0 current))
	     (> (nth 1 next-time) (nth 1 current)))
	(and (= (nth 0 next-time) (nth 0 current))
	     (= (nth 1 next-time) (nth 1 current))
	     (> (nth 2 next-time) (nth 2 current)))
	(progn
	  (timer-set-time timer (timer-next-integral-multiple-of-time
				 current imap-ping-interval)
			  imap-ping-handler)
	  (timer-activate timer)))))

(setq imap-ping-timer
      (run-at-time t imap-ping-interval 'imap-ping-handler))

;; Correct IMAP message and unread count. use %uy in gnus-groups-line-format
(defun gnus-user-format-function-t (dummy)
  (case (car gnus-tmp-method)
    (nnimap
     (message gnus-tmp-qualified-group)
     (let ((count (nnimap-request-message-count gnus-tmp-qualified-group gnus-tmp-news-server)))
       (if count
	   (format "%d" (car count))
	 "?")))
    (t
     gnus-tmp-number-total)))

(defun gnus-user-format-function-y (dummy)
  (case (car gnus-tmp-method)
    (nnimap
     (let ((count (nnimap-request-message-count gnus-tmp-qualified-group gnus-tmp-news-server)))
       (if count
	   (format "%d" (cadr count))
	 "?")))
    (t
     gnus-tmp-number-of-unread)))

(defvar nnimap-message-count-cache-alist nil)

(defun nnimap-message-count-cache-clear nil
  (setq nnimap-message-count-cache-alist nil))

(defun nnimap-message-count-cache-get (mbox &optional server)
  (when (nnimap-possibly-change-server server)
    (cadr (assoc (concat nnimap-current-server ":" mbox)
		 nnimap-message-count-cache-alist))))

(defun nnimap-message-count-cache-set (mbox count &optional server)
  (when (nnimap-possibly-change-server server)
    (push (list (concat nnimap-current-server ":" mbox)
		count) nnimap-message-count-cache-alist))
  count)

(defun nnimap-request-message-count (mbox &optional server)
  (let ((count (or (nnimap-message-count-cache-get mbox server)
		   (and (nnimap-possibly-change-server server)
			(progn
			  (message "Requesting message count for %s..."
				   mbox)
			  (prog1
			      (imap-mailbox-status
			       mbox '(messages unseen) nnimap-server-buffer)
			    (message "Requesting message count for %s...done"
				     mbox)))))))
    (when count
      (nnimap-message-count-cache-set mbox count server))
    count))

(add-hook 'gnus-after-getting-new-news-hook 'nnimap-message-count-cache-clear)