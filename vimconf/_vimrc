call dirsettings#Install()
filetype off
call pathogen#runtime_append_all_bundles()
filetype plugin indent on

set nocompatible

set tabstop=2
set shiftwidth=2
set softtabstop=2
set noexpandtab

set encoding=utf-8
set scrolloff=3
set autoindent
set showmode
set showcmd
syntax sync minlines=256
set hidden
set wildmenu
set wildmode=list:longest
set ttyfast
set ruler
set backspace=indent,eol,start
set laststatus=2
set undofile
set autoread

let mapleader = ","
let g:mapleader = ","

nnoremap ; :
vnoremap ; :
nnoremap / /\v
vnoremap / /\v
nnoremap <C-e> :e#<CR>
set ignorecase
set smartcase
set gdefault
set incsearch
set showmatch
nnoremap <leader><space> :noh<cr>
map <tab> g%
cmap w!! %!sudo tee > /dev/null %

set wrap
set textwidth=79
set formatoptions=qrn1
"set colorcolumn=79

"set list
"set listchars=tab:—\ ,eol:¬

" Swith syntax highlighting on, when the terminal has colors
" Also switching on highlighting the last used search pattern
"if (&t_Co > 2 || has("gui_running")) && !exists("syntax_on")
		syntax on
		"let g:zenburn_high_Contrast=1
		"let g:zenburn_alternate_Visual=1
		"let g:zenburn_alternate_Include=1
		"colorscheme zenburn
		"set hlsearch
"endif

" COLORS {
" syntax highlighting groups
hi Comment ctermfg=12
hi Constant ctermfg=15
hi Identifier ctermfg=4
hi Statement ctermfg=2
hi PreProc ctermfg=6
hi Type ctermfg=1
hi Special ctermfg=3
hi Underlined ctermfg=7
hi Ignore ctermfg=9
hi Error ctermfg=11
hi Todo ctermfg=1
hi Normal ctermfg=none ctermbg=none
hi NonText ctermfg=0 ctermbg=none
hi Directory ctermfg=12

hi VertSplit ctermfg=black
hi StatusLine ctermfg=green
hi StatusLineNC ctermfg=0

hi Folded ctermbg=0 ctermfg=8

hi Pmenu ctermfg=10 ctermbg=0
hi PmenuSel ctermfg=0 ctermbg=14
hi LineNr ctermfg=0 ctermbg=none
hi CursorLine ctermfg=none ctermbg=none cterm=none
hi CursorLineNr ctermfg=none ctermbg=0
hi CursorColumn ctermfg=none ctermbg=0

" Syntax checker colors
highlight SignColumn ctermbg=none
hi SyntasticErrorSign ctermfg=1 ctermbg=none
hi SyntasticWarningSign ctermfg=3 ctermbg=none
hi SyntasticStyleErrorSign ctermfg=1 ctermbg=none
hi SyntasticStyleWarningSign ctermfg=3 ctermbg=none
hi SyntasticErrorLine ctermfg=none ctermbg=none
hi SyntasticWarningLine ctermfg=none ctermbg=none
hi SyntasticStyleErrorLine ctermfg=none ctermbg=none
hi SyntasticStyleWarningLine ctermfg=none ctermbg=none
hi SpellBad ctermfg=0 ctermbg=3
hi SpellCap ctermfg=0 ctermbg=1

"}

set nuw=6
set number
"set cursorline
set clipboard=unnamedplus			 " X11 System Clipboard
set autowrite
set autoread

" Limit the amount of filesystem events
set nowritebackup
set nobackup
"set noswapfile

" Save your backups to a less annoying place than the current directory.
" If you have .vim-backup in the current directory, it'll use that.
" Otherwise it saves it to ~/.vim/backup or . if all else fails.
"if isdirectory($HOME . '/.vim/backup') == 0
  ":silent !mkdir -p ~/.vim/backup >/dev/null 2>&1
"endif
"set backupdir-=.
"set backupdir+=.
"set backupdir-=~/
"set backupdir^=~/.vim/backup/
"set backupdir^=./.vim-backup/
"set backup

" Save your swp files to a less annoying place than the current directory.
" If you have .vim-swap in the current directory, it'll use that.
" Otherwise it saves it to ~/.vim/swap, ~/tmp or .
if isdirectory($HOME . '/.vim/swap') == 0
	:silent !mkdir -p ~/.vim/swap >/dev/null 2>&1
endif
set directory=./.vim-swap//
set directory+=~/.vim/swap//
set directory+=~/tmp//
set directory+=.

" viminfo stores the the state of your previous editing session
set viminfo+=n~/.vim/viminfo

if exists("+undofile")
  " undofile - This allows you to use undos after exiting and restarting
  " This, like swap and backups, uses .vim-undo first, then ~/.vim/undo
  " :help undo-persistence
  " This is only present in 7.3+
  if isdirectory($HOME . '/.vim/undo') == 0
    :silent !mkdir -p ~/.vim/undo > /dev/null 2>&1
  endif
  set undodir=./.vim-undo//
  set undodir+=~/.vim/undo//
  set undofile
endif

augroup vimrcEx
	au!

	" When editing a file, always jump to the last known cursor position.
	" Don't do it when the position is invalid or when inside an event handler
	" (happens when dropping a file on gvim).
	autocmd BufReadPost *
				\ if line("'\'") > 0 && line("'\'") <= line("$") |
				\ exe "normal g`\"" |
				\ endif

	au FocusLost * :wa
	au BufWritePre * :%s/s+$//e	 " Remove trailing whitespace upon saving
augroup END

" Clean up trailing whitespace in the active file
nnoremap <leader>W :%s/\s\+$//<cr>:let @/=''<CR>

nnoremap <leader>a :Ack

" This will sort a CSS file by selector
nnoremap <leader>S ?{<CR>jV/^\s*\}?$<CR>k:sort<CR>:noh<CR>

" Select what you just pasted
nnoremap <leader>v V`]

" use jj to exit insert mode
inoremap jj <ESC>

" Create vertical split and switch to it
nnoremap <leader>w <C-w>v<C-w>l

" Split window navigation
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" Move around split lines
nnoremap j gj
nnoremap k gk

" Fast editing of the .vimrc
map <leader>e :e! ~/.vimrc<CR>

" Periodical auto-save
" Write to disk after 1 second of inactivity, once every 15 seconds.
au BufRead,BufNewFile * let b:last_autosave=localtime()
au CursorHold * call UpdateFile()
au BufWritePre * let b:last_autosave=localtime()
set updatetime=1000
function! UpdateFile()
	if exists("b:last_autosave") && ((localtime() - b:last_autosave) >= 15)
		update
		let b:last_autosave=localtime()
	endif
endfunction

au FileType html,xml,xsl source ~/.vim/scripts/closetag.vim
iabbrev </ </<C-X><C-O>
inoreabbrev lorem Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi.

" Ruby stuff
autocmd FileType ruby
					\ if expand('%') =~# '_test\.rb$' |
					\   compiler rubyunit | setl makeprg=testrb\ \"%:p\" |
					\ elseif expand('%') =~# '_spec\.rb$' |
					\  compiler rspec | setl makeprg=rspec\ \"%:p\" |
					\ else |
					\  compiler ruby | setl makeprg=ruby\ -wc\ \"%:p\" |
					\ endif

"autocmd FileType ruby :iabbrev <buffer> do do<CR>end<ESC>O

" Coffee Script mode: Enable folding
let coffee_folding = 1

" Ledger
au BufNewFile,BufRead *.ldg,*.ledger setf ledger | comp ledger
let g:ledger_maxwidth = 80
let g:ledger_fillstring = '	»'

" Markdown
au BufNewFile,BufRead *.md setf markdown setlocal tw=79 fo=tqan

" Haskellmode
"au Bufenter *.hs compiler ghc
"let g:haddock_browser = "firefox"

" CtrlP
set runtimepath^=~/.vim/bundle/ctrlp.vim
let g:ctrlp_map = '<Leader>t'
let g:ctrlp_working_path_mode = 'ra'

let g:ctrlp_custom_ignore = {
	\ 'dir':	'\v[\/]\.(git|hg|svn)|bourbon|neat|vendor$',
	\ 'file': '\v\.(exe|so|dll|pyc|wav|mp3|ogg|blend|swp|jpg|gif|png)$',
	\ }

"let g:ctrlp_user_command = {
	"\ 'types': {
		"\ 1: ['.git', 'cd %s && git ls-files'],
		"\ 2: ['.hg', 'hg --cwd %s locate -I .'],
		"\ },
	"\ 'fallback': 'find %s -type f'
	"\ }

iab <expr> ddate strftime("%Y/%m/%d")
